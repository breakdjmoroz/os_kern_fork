# Это форк проекта "Writing an Operating System in 1,000 Lines"
Ссылка на оригинальный проект: [https://github.com/nuta/operating-system-in-1000-linesa](https://github.com/nuta/operating-system-in-1000-linesa)

# Проект Bootstrap RISC-V в рамках Зимней Школы "Программирование для RISC-V" 2025

Bootstrapping - это процесс, во время которого происходит трансляция компилятора какого-нибудь языка
программирования из исходного текста, написанного на этом же языке (по-сути компиляция самого себя).

Такой подход может применяться для переноса компилятора на другую архитектуру или, как в нашем случае,
для сборки компилятора из исходников, которым мы доверяем.

Собирая компилятор с помощью bootstrap, мы исключаем возможные инЪекции.
Если нам нужно развернуть доверенную систему, то собирая её по
этой технологии, мы сможем обеспечить защиту от вредоносного кода, вшитого в инструменты сборки.

В рамках данного проекта нам было предложено перенести
[bootstrap систему](https://github.com/ironmeld/builder-hex0)
с x86 на RISC-V.

Над этой задачей работала команда из четырёх
человек в течение 5-ти дней:

- Наталья Букановская
- Алексей Курпяков
- Владимир Тронев
- Даниил Мороз

## Цели:

- Перенести систему под RISC-V, которая сможет компилировать сама себя
- Обеспечить безопасную загрузку системы

## Задачи:

- Разобраться в работе системы на x86
- Перенести его на RISC-V
- Провести Bootstrap проекта на новой архитектуре

## Ход работы:

Сперва мы исследовали наш исходный проект для x86.
Проект делится на две большие части. Первая - это
доверенная система, умеющая только компилировать
программы на hex0 (hex-представление исполняемого файла + возможность оставлять комментарии).
Вторая - маленькая операционная система, поддерживающая работу
с процессами, файлами, имеющая минимальный интерпретатор командной строки
и всё так же обеспечивающая компиляцию hex0. Предполагается, что
в процессе bootstrap первая система скомпилирует сама себя,
самоскомпилированная система проделает это ещё раз, и дважды самоскомпилированная
система начнёт компиляцию второй системы, которая повторит все этапы
сборки первой. В конечном итоге готовая система может скомпилировать
компилятор языка Си, с помощью которого можно собрать Линукс.

Вторым шагом мы попытались портировать исходные тексты этих
двух программ на RISC-V (по-сути, эти программы - hex-представление
опкодов RISC-V инструкций). Проект использовал прерывания BIOS для
работы с внешним диском. Мы приняли решение написать драйвер блочного
устройства, так как в OpenSBI (аналоге BIOS для RISC-V) не поддержан
функционал работы с hdd. Работали мы с эмулятором QEMU, так что драйвер
был расчитан на виртуальной блочное устройство (интерфейс virtio-blk).
Однако, у нас не получилось это сделать и ввиду ограничений по времени
мы сделали форк проекта, о котором сказано в самом начале.

Так как мы взяли готову систему, нам оставалось только организовать
концепцию bootstrap и, соответственно, реализовать компиляцию hex0.

## Результаты:

### Удалось:

    - Изучить исходный проект для x86
    - Провести Bootstrap минимальной версии системы

### Не удалось:

    - Выполнить самостоятельный перенос всех частей проекта на RISC-V
    - Провести самокомпиляцию полной версии системы

# Структура проекта:

## root

Здесь лежит Makefile для запуска всего проекта.

В процессе работы по завершении каждой компиляции
необходимо ввести комбинацию Ctrl-A x для продолжения
компиляции.

В результате работы должна загрузиться полная система
в которой будет запущен интерпретатор коммандной строки.

Поддерживаемые комманды:

- hex0 - компиляция файла root/disk/program.hex0 в root/disk.tar/program.bin
- hello - вывод строки "Hello world from shell!"
- writefile - Запись в файл root/disk.tar/hello.txt
- readfile - Чтение файла root/disk/hello.txt

### scripts

Здесь лежат скрипты сборки:

- build_mini.sh - сборка мини-системы из исходников
- build.sh - сборка полной системы из исходников
- run.sh - запуск виртуальной машины

#### Использование run.sh:

run.sh <образ_системы> <образ_диска>

- <образ_системы> - это elf-файл, загружающийся в qemu под флагом -kernel
- <образ_диска> - это бинарный файл, загружающийся в qemu в качестве виртуального диска

### src

Здесь лежат исходный текст всего проекта на языке Си, а также скрипты компоновщика \*.ld \*.map

Также здесь присутствует Makefile, занимающийся сборкой kernel.elf.
По каким-то причинам, сборка должна происходить в одной директории, поэтому
мы пошли на такой шаг.

### img

Здесь лежат исполняемые файлы, полученные в ходе самокомпиляции системы

### build

Здесь лежат исполняемые файлы, полученные в ходе компиляции из исходников

